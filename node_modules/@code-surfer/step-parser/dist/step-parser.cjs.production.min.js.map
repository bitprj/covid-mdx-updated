{"version":3,"file":"step-parser.cjs.production.min.js","sources":["../src/differ.ts","../src/tokenizer.ts","../src/focus-parser.ts","../src/step-parser.ts","../src/object-entries.ts"],"sourcesContent":["import { diffLines } from \"diff\";\n\nString.prototype.trimEnd =\n  String.prototype.trimEnd ||\n  function(this: string) {\n    if (String.prototype.trimRight) {\n      return this.trimRight();\n    } else {\n      const trimmed = this.trim();\n      const indexOfWord = this.indexOf(trimmed);\n\n      return this.slice(indexOfWord, this.length);\n    }\n  };\n\nfunction getChanges(oldCode: string, newCode: string) {\n  const changes = diffLines(normalize(oldCode), normalize(newCode));\n  let index = 0;\n  const chunks: { op: \"-\" | \"+\"; count: number; index: number }[] = [];\n  changes.forEach(({ count = 0, removed, added }) => {\n    if (removed) {\n      chunks.push({\n        op: \"-\",\n        count,\n        index\n      });\n    }\n\n    if (added) {\n      chunks.push({\n        op: \"+\",\n        count,\n        index\n      });\n    }\n\n    if (!removed) {\n      index += count;\n    }\n  });\n\n  return chunks;\n}\n\nfunction normalize(text: string) {\n  return text && text.trimEnd().concat(\"\\n\");\n}\n\nexport function generateIds(\n  lineIds: number[],\n  afterId: number = 0,\n  count: number\n) {\n  const afterIndex = lineIds.indexOf(afterId);\n  const beforeIndex = afterIndex + 1;\n  const aid = afterId || 0;\n  const bid = lineIds[beforeIndex] || 1;\n\n  const newIds = Array(count)\n    .fill(0)\n    .map((_, i) => aid + ((bid - aid) * (i + 1)) / (count + 1));\n\n  lineIds.splice(afterIndex + 1, 0, ...newIds);\n  return newIds;\n}\n\nfunction getStepIds(\n  lineIds: number[],\n  oldStepIds: number[] = [],\n  oldStepCode: string = \"\",\n  newStepCode: string = \"\"\n): number[] {\n  const changes = getChanges(oldStepCode, newStepCode);\n\n  const newStepIds = oldStepIds.slice(0);\n  changes.forEach(({ op, count, index }) => {\n    if (op === \"-\") {\n      newStepIds.splice(index, count);\n    } else {\n      const afterId = newStepIds[index - 1];\n      const newIds = generateIds(lineIds, afterId, count);\n      newStepIds.splice(index, 0, ...newIds);\n    }\n  });\n  return newStepIds;\n}\n\nexport function linesDiff(codeList: string[]) {\n  const steps: number[][] = [];\n  const lineIds: number[] = [];\n  codeList.forEach((_, i) => {\n    steps.push(getStepIds(lineIds, steps[i - 1], codeList[i - 1], codeList[i]));\n  });\n  return { lineIds, steps };\n}\n","// // https://github.com/PrismJS/prism/issues/1303#issuecomment-375353987\n// global.Prism = { disableWorkerMessageHandler: true };\n// const Prism = require(\"prismjs\");\nimport Prism from \"prismjs\";\nconst newlineRe = /\\r\\n|\\r|\\n/;\n\nexport function tokenize(code: string, lang: string) {\n  const grammar = Prism.languages[lang];\n  if (!grammar) {\n    throw new MissingGrammarError(lang);\n  }\n\n  const prismTokens = Prism.tokenize(code, Prism.languages[lang]);\n  const nestedTokens = tokenizeStrings(prismTokens);\n  const tokens = flattenTokens(nestedTokens);\n\n  let currentLine: FlatToken[] = [];\n  let currentTokenLine: string[] = [];\n  let currentTypeLine: string[] = [];\n\n  const lines = [currentLine];\n  const tokenLines = [currentTokenLine];\n  const typeLines = [currentTypeLine];\n\n  tokens.forEach(token => {\n    const contentLines = token.content.split(newlineRe);\n\n    const firstContent = contentLines.shift();\n    if (firstContent !== undefined && firstContent !== \"\") {\n      currentLine.push({ type: token.type, content: firstContent });\n      currentTokenLine.push(firstContent);\n      currentTypeLine.push(token.type);\n    }\n    contentLines.forEach(content => {\n      currentLine = [];\n      currentTokenLine = [];\n      currentTypeLine = [];\n      lines.push(currentLine);\n      tokenLines.push(currentTokenLine);\n      typeLines.push(currentTypeLine);\n      if (content !== \"\") {\n        currentLine.push({ type: token.type, content });\n        currentTokenLine.push(content);\n        currentTypeLine.push(token.type);\n      }\n    });\n  });\n  return {\n    tokens: tokenLines,\n    types: typeLines\n  };\n}\n\ntype NestedToken = {\n  type: string;\n  content: string | NestedToken[];\n};\n\nfunction tokenizeStrings(\n  prismTokens: (string | Prism.Token)[],\n  parentType = \"plain\"\n): NestedToken[] {\n  return prismTokens.map(prismToken => wrapToken(prismToken, parentType));\n}\n\nfunction wrapToken(\n  prismToken: string | Prism.Token,\n  parentType = \"plain\"\n): NestedToken {\n  if (typeof prismToken === \"string\") {\n    return {\n      type: parentType,\n      content: prismToken\n    };\n  }\n\n  if (Array.isArray(prismToken.content)) {\n    return {\n      type: prismToken.type,\n      content: tokenizeStrings(prismToken.content, prismToken.type)\n    };\n  }\n\n  return wrapToken(prismToken.content, prismToken.type);\n}\n\ntype FlatToken = {\n  type: string;\n  content: string;\n};\n\n// Take a list of nested tokens\n// (token.content may contain an array of tokens)\n// and flatten it so content is always a string\n// and type the type of the leaf\nfunction flattenTokens(tokens: NestedToken[]) {\n  const flatList: FlatToken[] = [];\n  tokens.forEach(token => {\n    const { type, content } = token;\n    if (Array.isArray(content)) {\n      flatList.push(...flattenTokens(content));\n    } else {\n      flatList.push({ type, content });\n    }\n  });\n  return flatList;\n}\n\nexport class MissingGrammarError extends Error {\n  lang: string;\n  constructor(lang: string) {\n    super(`Missing syntax highlighting for language \"${lang}\"`);\n    this.lang = lang;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import flat from \"array.prototype.flat\";\nimport { fromEntries } from \"./object-entries\";\n\ntype LineIndex = number;\ntype ColumnIndex = number;\n\nexport function parseFocus(focus: string) {\n  if (!focus) {\n    throw new Error(\"Focus cannot be empty\");\n  }\n\n  try {\n    const parts = focus.split(/,(?![^\\[]*\\])/g).map(parsePart);\n    return fromEntries(flat(parts));\n  } catch (error) {\n    // TODO enhance error\n    throw error;\n  }\n}\n\ntype Part = [LineIndex, true | ColumnIndex[]];\n\nfunction parsePart(part: string): Part[] {\n  // a part could be\n  // - a line number: \"2\"\n  // - a line range: \"5:9\"\n  // - a line number with a column selector: \"2[1,3:5,9]\"\n  const columnsMatch = part.match(/(\\d+)\\[(.+)\\]/);\n  if (columnsMatch) {\n    const [, line, columns] = columnsMatch;\n    const columnsList = columns.split(\",\").map(expandString);\n    const lineIndex = Number(line) - 1;\n    const columnIndexes = flat(columnsList).map(c => c - 1);\n    return [[lineIndex, columnIndexes]];\n  } else {\n    return expandString(part).map(lineNumber => [lineNumber - 1, true]);\n  }\n}\n\nfunction expandString(part: string) {\n  // Transforms something like\n  // - \"1:3\" to [1,2,3]\n  // - \"4\" to [4]\n  const [start, end] = part.split(\":\");\n\n  if (!isNaturalNumber(start)) {\n    throw new FocusNumberError(start);\n  }\n\n  const startNumber = Number(start);\n\n  if (startNumber < 1) {\n    throw new LineOrColumnNumberError();\n  }\n\n  if (!end) {\n    return [startNumber];\n  } else {\n    if (!isNaturalNumber(end)) {\n      throw new FocusNumberError(end);\n    }\n\n    const list: number[] = [];\n    for (let i = startNumber; i <= +end; i++) {\n      list.push(i);\n    }\n    return list;\n  }\n}\n\nfunction isNaturalNumber(n: any) {\n  n = n.toString(); // force the value in case it is not\n  var n1 = Math.abs(n),\n    n2 = parseInt(n, 10);\n  return !isNaN(n1) && n2 === n1 && n1.toString() === n;\n}\n\nexport function getFocusSize(focus: Record<LineIndex, true | ColumnIndex[]>) {\n  const lineIndexList = Object.keys(focus).map(k => +k);\n  const focusStart = Math.min.apply(Math, lineIndexList);\n  const focusEnd = Math.max.apply(Math, lineIndexList);\n  return {\n    focusCenter: (focusStart + focusEnd + 1) / 2,\n    focusCount: focusEnd - focusStart + 1\n  };\n}\n\nexport class LineOrColumnNumberError extends Error {\n  constructor() {\n    super(`Invalid line or column number in focus string`);\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n\nexport class FocusNumberError extends Error {\n  number: string;\n  constructor(number: string) {\n    super(`Invalid number \"${number}\" in focus string`);\n    this.number = number;\n    Object.setPrototypeOf(this, new.target.prototype);\n  }\n}\n","import { linesDiff } from \"./differ\";\nimport { tokenize } from \"./tokenizer\";\nimport { parseFocus, getFocusSize } from \"./focus-parser\";\nimport { toEntries } from \"./object-entries\";\nimport { applyPatch } from \"diff\";\n\nexport function parseSteps(\n  inputSteps: {\n    code: string;\n    focus?: string;\n    lang?: string;\n    title?: string;\n    subtitle?: string;\n  }[]\n) {\n  if (inputSteps.length === 0) {\n    return {\n      tokens: [],\n      types: [],\n      steps: []\n    };\n  }\n\n  const lang = inputSteps[0].lang;\n\n  if (!lang) {\n    throw new Error(\"Missing code language\");\n  }\n\n  const codeList = getCodeList(inputSteps);\n\n  const { lineIds, steps } = linesDiff(codeList);\n  const allTokens: string[][] = [];\n  const allTypes: string[][] = [];\n  const allSteps: {\n    lines: number[];\n    focus: Record<number, true | number[]>;\n    focusCenter: number;\n    focusCount: number;\n    longestLineIndex: number;\n    title?: string;\n    subtitle?: string;\n  }[] = [];\n\n  steps.forEach((step, i) => {\n    const code = codeList[i];\n    const { tokens, types } = tokenize(code, lang);\n    const lineKeys: number[] = [];\n    step.forEach((lineId, lineIndex) => {\n      const lineKey = lineIds.indexOf(lineId);\n      allTokens[lineKey] = tokens[lineIndex];\n      allTypes[lineKey] = types[lineIndex];\n      lineKeys.push(lineKey);\n    });\n\n    const focusString = inputSteps[i].focus;\n    const prevLineKeys = allSteps[i - 1] ? allSteps[i - 1].lines : [];\n    const focus = focusString\n      ? parseFocus(focusString)\n      : getDefaultFocus(prevLineKeys, lineKeys);\n    const { focusCenter, focusCount } = getFocusSize(focus);\n    allSteps.push({\n      lines: lineKeys,\n      focus,\n      focusCenter,\n      focusCount,\n      longestLineIndex: getLongestLineIndex(code),\n      title: inputSteps[i].title,\n      subtitle: inputSteps[i].subtitle\n    });\n  });\n\n  // split tokens into columns when needed\n  allSteps.forEach(({ lines, focus }) => {\n    toEntries(focus).forEach(([lineIndex, lineFocus]) => {\n      if (Array.isArray(lineFocus)) {\n        const lineKey = lines[lineIndex];\n        const lineTypes = allTypes[lineKey];\n        const lineTokens = allTokens[lineKey];\n        const [newTypes, newTokens] = splitIntoColumns(lineTypes, lineTokens);\n        allTypes[lineKey] = newTypes;\n        allTokens[lineKey] = newTokens;\n      }\n    });\n  });\n\n  // add empty char to empty lines\n  allTokens.forEach((line, lineKey) => {\n    if (line.length === 0) {\n      line.push(`\\u200B`);\n      allTypes[lineKey].push(\"plain\");\n    }\n  });\n\n  return {\n    tokens: allTokens,\n    types: allTypes,\n    steps: allSteps\n  };\n}\n\nfunction getCodeList(\n  inputSteps: {\n    code: string;\n    lang?: string | undefined;\n  }[]\n) {\n  const firstLang = inputSteps[0].lang;\n  if (firstLang === \"diff\") {\n    return inputSteps.map(s => s.code);\n  }\n\n  let prevCode = \"\";\n  return inputSteps.map(({ code, lang }) => {\n    let stepCode = lang === \"diff\" ? applyPatch(prevCode, code) : code;\n    prevCode = stepCode;\n    return stepCode;\n  });\n}\n\nfunction splitIntoColumns(\n  types: string[],\n  tokens: string[]\n): [string[], string[]] {\n  const newTypes: string[] = [];\n  const newTokens: string[] = [];\n  tokens.forEach((token, i) => {\n    const tokenType = types[i];\n    Array.from(token).forEach(char => {\n      newTokens.push(char);\n      newTypes.push(tokenType);\n    });\n  });\n  return [newTypes, newTokens];\n}\n\nfunction getDefaultFocus(prevLineKeys: number[], lineKeys: number[]) {\n  const focus = {} as Record<number, true>;\n  lineKeys.forEach((lineKey, lineIndex) => {\n    if (!prevLineKeys.includes(lineKey)) {\n      focus[lineIndex] = true;\n    }\n  });\n\n  if (Object.keys(focus).length === 0) {\n    lineKeys.forEach((_, lineIndex) => {\n      focus[lineIndex] = true;\n    });\n  }\n\n  return focus;\n}\n\nfunction getLongestLineIndex(code: string) {\n  const newlineRe = /\\r\\n|\\r|\\n/;\n  const lines = code.split(newlineRe);\n\n  let longest = 0;\n  lines.forEach((line, i) => {\n    if (lines[longest].length < line.length) {\n      longest = i;\n    }\n  });\n\n  return longest;\n}\n","export function fromEntries<K extends string | number | symbol, V>(\n  pairs: [K, V][]\n) {\n  const result = {} as Record<K, V>;\n\n  let index = -1,\n    length = pairs == null ? 0 : pairs.length;\n\n  while (++index < length) {\n    var pair = pairs[index];\n    result[pair[0]] = pair[1];\n  }\n\n  return result;\n}\n\nexport function toEntries<K extends string | number | symbol, V>(\n  o: Record<K, V>\n): [K, V][] {\n  const keys = Object.keys(o) as K[];\n  return keys.map(k => [k, o[k]]);\n}\n"],"names":["normalize","text","trimEnd","concat","String","prototype","trimRight","this","trimmed","trim","indexOfWord","indexOf","slice","length","newlineRe","MissingGrammarError","lang","Object","setPrototypeOf","Error","parsePart","part","columnsMatch","match","line","columnsList","split","map","expandString","Number","flat","c","lineNumber","start","end","isNaturalNumber","FocusNumberError","startNumber","LineOrColumnNumberError","list","i","push","n","toString","n1","Math","abs","n2","parseInt","isNaN","number","getLongestLineIndex","code","lines","longest","forEach","inputSteps","tokens","types","steps","codeList","s","prevCode","stepCode","applyPatch","getCodeList","lineIds","_","oldStepIds","oldStepCode","newStepCode","changes","oldCode","newCode","diffLines","index","chunks","count","removed","added","op","getChanges","newStepIds","splice","newIds","afterId","afterIndex","aid","bid","Array","fill","generateIds","getStepIds","linesDiff","allTokens","allTypes","allSteps","step","Prism","languages","flattenTokens","flatList","token","type","content","isArray","tokenizeStrings","prismTokens","parentType","prismToken","wrapToken","tokenize","currentLine","currentTokenLine","currentTypeLine","tokenLines","typeLines","contentLines","firstContent","shift","undefined","lineKeys","lineId","lineIndex","lineKey","focusString","focus","prevLineKeys","parts","pairs","result","pair","fromEntries","error","parseFocus","includes","keys","getDefaultFocus","lineIndexList","k","focusStart","min","apply","focusEnd","max","focusCenter","focusCount","getFocusSize","longestLineIndex","title","subtitle","o","newTypes","newTokens","tokenType","from","char","splitIntoColumns"],"mappings":"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"}